=== Sorting Algorithms

Sorting is one of the most common solutions when we want to extract some insights about a collection of data.
We can sort to get the maximum or minimum value and many algorithmic problems involves sorting data first.

.We are going to explore three basic sorting algorithms _O(n^2^)_ which have low overhead:
- <<Bubble Sort>>
- <<Selection Sort>>
- <<Insertion Sort>>

.and then discuss efficient sorting algorithms _O(n log n)_ such as:
- <<Merge Sort>>
- <<Quicksort>>

Before we dive into the most well-known sorting algorithms, let's discuss the sorting properties.

==== Sorting Properties

Sorting implementations with the same time complexity might manipulate the data differently. We want to understand these differences so we can be aware of the side-effects it will have on data or extra resources they will require. For instance, some solutions will need auxiliary memory to store temporary data while sorting while others can do it in place.

Sorting properties are stable, adaptive, online and in-place. Let's go one by one.

===== Stable
(((Sorting, stable)))
An ((stable sorting)) algorithms keep the relative order of items with the same comparison criteria.

This especially useful when you want to sort on multiple phases.

.Let's say you have the following data:
[source, javascript]
----
const users = [
  { name: 'Bob', age: 32 },
  { name: 'Alice', age: 30 },
  { name: 'Don', age: 30 },
  { name: 'Charly', age: 32 },
];
----

.If you sort by `name` you would have:
[source, javascript]
----
[
  { name: 'Alice', age: 30 },
  { name: 'Bob', age: 32 },
  { name: 'Charly', age: 32 },
  { name: 'Don', age: 30 },
];
----

Then, here comes the _critical_ part, if you sort by `age` you might get (at least two) different results.

.If the sorting algorithm is *stable*; it should keep the items with the same age ordered by `name`:
[source, javascript]
----
[
  { name: 'Alice', age: 30 },
  { name: 'Don', age: 30 },
  { name: 'Bob', age: 32 },
  { name: 'Charly', age: 32 },
];
----

.However, if the sorting is *not stable*, then you will lose the relative order of the items and get something like this:
[source, javascript]
----
[
  { name: 'Don', age: 30 },
  { name: 'Alice', age: 30 },
  { name: 'Charly', age: 32 },
  { name: 'Bob', age: 32 },
];
----

Both results are sorted by `age`; however, having a stable sorting is better if you want to keep the relative position of data with the same value.

===== In-place
(((Sorting, in-place)))
An ((in-place sorting)) algorithm would have a _space complexity_ of O(1). In other words, it does not use any other auxiliary memory because it moves the items in the collection itself.
No requiring extra memory for sorting is especially useful for memory constraint environments like robotics, smart devices, or embedded systems in appliances.

===== Online
(((Sorting, online)))
It can sort a list as it receives it.
((Online sorting)) algorithms don't have to re-sort the whole collection for every new item added.

===== Adaptive
(((Sorting, adaptive)))
Algorithms with ((adaptive sorting)) run faster, close to _O(n)_, on an already sorted (or partially sorted) collection.

<<<
include::bubble-sort.asc[]

<<<
include::insertion-sort.asc[]

<<<
include::selection-sort.asc[]

<<<
include::merge-sort.asc[]

<<<
include::quick-sort.asc[]

<<<
==== Summary

We explored many algorithms some of them simple and other more performant. Also, we cover the properties of sorting algorithms such as stable, in-place, online and adaptive.
(((Tables, Algorithms, Sorting Complexities)))
(((Tables, Algorithms, Sorting Summary)))

// tag::table[]
.Sorting algorithms comparison
[cols="20,80"]
|===
| Algorithms         | Comments
| <<Bubble Sort>>    | Swap pairs bubbling up largest numbers to the right
| <<Insertion Sort>> | Look for biggest number to the left and swap it with current
| <<Selection Sort>> | Iterate array looking for smallest value to the right
| <<Merge Sort>>     | Split numbers in pairs, sort pairs and join them in ascending order
| <<Quicksort>>      | Choose a pivot, set smaller values to the left and bigger to the right.
// | Tim sort        | Hybrid of merge sort and insertion sort
|===

.Sorting algorithms time/space complexity and properties
|===
| Algorithms         | Avg        | Best | Worst | Space       | Stable | In-place | Online | Adaptive
| <<Bubble Sort>>    | O(n^2^)    | O(n) | O(n^2^) | O(1)      | Yes    | Yes      | Yes    | Yes
| <<Insertion Sort>> | O(n^2^)    | O(n) | O(n^2^) | O(1)      | Yes    | Yes      | Yes    | Yes
| <<Selection Sort>> | O(n^2^)    | O(n^2^) | O(n^2^) | O(1)        | No     | Yes      | No    | No
| <<Merge Sort>>     | O(n log n) | O(n log n) | O(n log n) | O(n)        | Yes     | No       | No     | No
| <<Quicksort>>      | O(n log n) | O(n^2^) | O(n log n) | O(log n)    | Yes     | Yes      | No     | No
// | Tim sort       | O(n log n) | O(log n)    | Yes    | No       | No     | Yes
|===
// end::table[]

